{"title":"識別HTML5 Canvas上的圖形（直線、箭號、圓形、矩形...）","uid":"2d4b14f1414f66f6c6120a91d5af0cc2","slug":"js-shape-recognition","date":"2021-10-26T02:52:47.000Z","updated":"2021-12-16T01:39:02.565Z","comments":true,"path":"api/articles/js-shape-recognition.json","keywords":"Flutter, Dart, MSIX, webview_windows, Javascript, Web, VBA, Excel","cover":null,"content":"<p>在iOS的備忘錄或Samsung Note App裡畫畫都可以將手畫的筆跡轉換成漂亮的圖形，讓我不禁想嘗試HTML5的Canvas是不是也可以做到，今天就來記錄一下如何將HTML5 Canvas上醜醜的圖形變成漂亮的直線、箭號、矩形等等。</p>\n<h3 id=\"開心地展示時間\"><a href=\"#開心地展示時間\" class=\"headerlink\" title=\"開心地展示時間\"></a>開心地展示時間</h3><p class=\"codepen\" data-height=\"300\" data-slug-hash=\"zYdNBxM\" data-preview=\"true\" data-editable=\"true\" data-user=\"cailirl980519\" style=\"height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\">\n  <span>See the Pen <a href=\"https://codepen.io/cailirl980519/pen/zYdNBxM\">\n  Shape Recognition</a> by cailirl980519 (<a href=\"https://codepen.io/cailirl980519\">@cailirl980519</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://cpwebassets.codepen.io/assets/embed/ei.js\"></script>\n\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><h4 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h4><p>首先，先在頁面創建一個<code>&lt;canvas&gt;</code>用來畫畫，再創建一個<code>&lt;button&gt;</code>來清除畫布</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;canvas id&#x3D;&quot;canvas&quot;&gt;&lt;&#x2F;canvas&gt;\n&lt;div id&#x3D;&quot;menu&quot;&gt;\n  &lt;button id&#x3D;&quot;clear&quot; onclick&#x3D;&quot;reset()&quot;&gt;clear&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<h4 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h4><p>再來用CSS排個版～</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">#canvas &#123;\n  width: 100vw;\n  height: 100vh;\n&#125;\n#menu &#123;\n  position: absolute;\n  top: 10px;\n  left: 10px;\n  z-index: 1;\n&#125;</code></pre>\n\n<h4 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h4><p>先宣告幾個等等需要用到的參數，並將偵測動作加入畫布</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">const isMobile &#x3D; window.orientation !&#x3D;&#x3D; undefined;\nconst canvas &#x3D; document.getElementById(&quot;canvas&quot;);\n&#x2F;&#x2F; 設定畫布大小\ncanvas.width &#x3D; canvas.clientWidth;\ncanvas.height &#x3D; canvas.clientHeight;\nconst ctx &#x3D; canvas.getContext(&quot;2d&quot;);\n&#x2F;&#x2F; 設定畫布樣式\nctx.fillStyle &#x3D; &quot;lightgray&quot;;\nctx.lineWidth &#x3D; 2;\nctx.font &#x3D; &quot;30px Arial&quot;;\n&#x2F;&#x2F; 記錄筆跡的參數\nvar drawCache &#x3D; new Array();\nvar lineCache &#x3D; new Array();\n&#x2F;&#x2F; 偵測畫布動作\nif (isMobile) &#123;\n  canvas.addEventListener(&quot;touchstart&quot;, handleDraw);\n  canvas.addEventListener(&quot;touchmove&quot;, handleDraw);\n  canvas.addEventListener(&quot;touchend&quot;, handleDraw);\n&#125; else &#123;\n  canvas.addEventListener(&quot;pointerdown&quot;, handleDraw);\n  canvas.addEventListener(&quot;pointermove&quot;, handleDraw);\n  canvas.addEventListener(&quot;pointerup&quot;, handleDraw);\n  canvas.addEventListener(&quot;pointercancel&quot;, handleDraw);\n&#125;</code></pre>\n\n<p>接下來宣告一個<code>handleDraw</code> function來執行偵測到畫布動作後需要做的事情：</p>\n<ul>\n<li>偵測到這些動作時，將目前觸碰到的點加入<code>lineCache</code>陣列裡<ul>\n<li>pointerdown</li>\n<li>pointermove</li>\n<li>touchstart</li>\n<li>touchmove</li>\n</ul>\n</li>\n<li>偵測到這些動作時，利用<code>detectShape</code>判斷圖形，再將偵測到的圖形及目前的線段<code>lineCache</code>新增至<code>drawCache</code><ul>\n<li>pointerup</li>\n<li>pointercancel</li>\n<li>touchend</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function handleDraw(e) &#123;\n  e.preventDefault();\n  if (\n    (isMobile &amp;&amp; (e.type &#x3D;&#x3D; &quot;touchstart&quot; || e.type &#x3D;&#x3D; &quot;touchmove&quot;)) ||\n    (e.buttons &#x3D;&#x3D; 1 &amp;&amp; (e.type &#x3D;&#x3D; &quot;pointerdown&quot; || e.type &#x3D;&#x3D; &quot;pointermove&quot;))\n  ) &#123;\n    &#x2F;&#x2F; 將目前觸碰到的點加入&#96;lineCache&#96;陣列裡\n    lineCache.push(&#123;\n      x: isMobile ? e.touches[0].clientX : e.clientX,\n      y: isMobile ? e.touches[0].clientY : e.clientY\n    &#125;);\n    draw(); &#x2F;&#x2F; 更新畫布\n  &#125; else if (\n    e.type &#x3D;&#x3D; &quot;pointerup&quot; ||\n    e.type &#x3D;&#x3D; &quot;pointercancel&quot; ||\n    e.type &#x3D;&#x3D; &quot;touchend&quot;\n  ) &#123;\n    if (lineCache.length &gt; 1) &#123;\n      detectShape(lineCache); &#x2F;&#x2F; 偵測圖形\n    &#125;\n    lineCache &#x3D; new Array();\n    draw(); &#x2F;&#x2F; 更新畫布\n  &#125;\n&#125;</code></pre>\n\n<p>接著就是今天的重點<code>detectShape</code></p>\n<ol>\n<li>先將三個連續點變為兩個線段，並判斷兩個線段的角度，如果大於<code>Math.PI / 4</code>則認定它為角</li>\n<li>計算所有認定為角的平均角度</li>\n<li>判斷第一個點跟最後一個點的距離是否小於30，如是，則認定為封閉的圖形，並將<strong>第一個點</strong>加入<code>corners</code>的最後一項</li>\n<li>若為封閉的圖形，則利用<code>avgA</code>判斷是否為<strong>圓形</strong>或<strong>橢圓形</strong></li>\n<li>若為封閉的圖形，且不是圓形或橢圓形，並有5個角，則可以認定它為<strong>四方形</strong>，接著就繼續判斷是否為<strong>矩形</strong></li>\n<li>若不為封閉的圖形，則將<strong>最後一個</strong>點加入<code>corners</code>的最後一項</li>\n<li>若不為封閉的圖形，則判斷是否為曲線、直線或箭號</li>\n</ol>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function detectShape(points) &#123;\n  let ptLast &#x3D; &#123; ...points[points.length - 1] &#125;;\n  ptLast.index &#x3D; points.length - 1;\n  &#x2F;&#x2F; 線段轉彎的地方（角）\n  let corners &#x3D; [points[0]];\n  let n &#x3D; 0;\n  let t &#x3D; 0;\n  let lastCorner &#x3D; points[0];\n  let angles &#x3D; 0;\n  let avgA;\n  &#x2F;&#x2F; 1. 判斷是否為角\n  for (let i &#x3D; 1; i &lt; points.length - 2; i++) &#123;\n    let pt &#x3D; points[i + 1];\n    let d &#x3D; delta(lastCorner, points[i - 1]);\n    if (len(d) &gt; 20 &amp;&amp; n &gt; 2) &#123;\n      ac &#x3D; delta(points[i - 1], pt);\n      if (Math.abs(angle_between(ac, d)) &gt; Math.PI &#x2F; 4) &#123;\n        angles +&#x3D; (angle_between(ac, d) * 180) &#x2F; Math.PI;\n        pt.index &#x3D; i;\n        corners.push(pt);\n        lastCorner &#x3D; pt;\n        n &#x3D; 0;\n        t &#x3D; 0;\n      &#125;\n    &#125;\n    n++;\n  &#125;\n  &#x2F;&#x2F; 2. 計算所有角的平均角度\n  avgA &#x3D; angles &#x2F; corners.length;\n  &#x2F;&#x2F; 3. 判斷是否為封閉的圖形\n  if (len(delta(points[points.length - 1], points[0])) &lt; 30) &#123;\n    &#x2F;&#x2F; 3. 將第一個點加入corners最後一項\n    ptLast &#x3D; &#123; ...points[0] &#125;;\n    ptLast.index &#x3D; 0;\n    corners.push(ptLast);\n    &#x2F;&#x2F; 4. 判斷是否為圓形或橢圓形\n    if (avgA &lt; 45) &#123;\n      let l &#x3D; points.length;\n      let ps &#x3D; [...points];\n      let left &#x3D; ps.sort((a, b) &#x3D;&gt; a.x - b.x)[0];\n      let right &#x3D; ps.sort((a, b) &#x3D;&gt; b.x - a.x)[0];\n      let top &#x3D; ps.sort((a, b) &#x3D;&gt; a.y - b.y)[0];\n      let bottom &#x3D; ps.sort((a, b) &#x3D;&gt; b.y - a.y)[0];\n      corners &#x3D; [left, right, top, bottom];\n      drawCache.push(&#123;\n        type: &quot;circle&quot;,\n        corners: corners,\n        line: [...lineCache]\n      &#125;);\n      return;\n    &#125;\n    &#x2F;&#x2F; 5. 判斷是否為四方形\n    if (corners.length &#x3D;&#x3D; 5) &#123;\n      let p0 &#x3D; corners[0];\n      let p1 &#x3D; corners[1];\n      let p2 &#x3D; corners[2];\n      let p3 &#x3D; corners[3];\n      let p0p1 &#x3D; delta(p0, p1);\n      let p1p2 &#x3D; delta(p1, p2);\n      let p2p3 &#x3D; delta(p2, p3);\n      let p3p0 &#x3D; delta(p3, p0);\n      &#x2F;&#x2F; 5. 判斷是否為矩形\n      if (\n        Math.abs(angle_between(p0p1, p1p2) - Math.PI &#x2F; 2) &lt; Math.PI &#x2F; 6 &amp;&amp;\n        Math.abs(angle_between(p1p2, p2p3) - Math.PI &#x2F; 2) &lt; Math.PI &#x2F; 6 &amp;&amp;\n        Math.abs(angle_between(p2p3, p3p0) - Math.PI &#x2F; 2) &lt; Math.PI &#x2F; 6 &amp;&amp;\n        Math.abs(angle_between(p3p0, p0p1) - Math.PI &#x2F; 2) &lt; Math.PI &#x2F; 6\n      ) &#123;\n        let p0p2 &#x3D; delta(p0, p2);\n        let p1p3 &#x3D; delta(p1, p3);\n        let diag &#x3D; (len(p0p2) + len(p1p3)) &#x2F; 4;\n        let tocenter0 &#x3D; scale(unit(p0p2), -diag);\n        let tocenter1 &#x3D; scale(unit(p1p3), -diag);\n        let center &#x3D; average(corners);\n        let angle &#x3D; angle_between(p0p2, p1p3);\n        corners &#x3D; [\n          add(center, tocenter0),\n          add(center, tocenter1),\n          add(center, scale(tocenter0, -1)),\n          add(center, scale(tocenter1, -1)),\n          add(center, tocenter0)\n        ];\n        drawCache.push(&#123;\n          type: &quot;rect&quot;,\n          corners: corners,\n          line: [...lineCache]\n        &#125;);\n        return;\n      &#125;\n    &#125;\n  &#125; else &#123; &#x2F;&#x2F; 不是封閉的圖形\n    &#x2F;&#x2F; 6. 將最後一個點加入corners最後一項\n    corners.push(ptLast);\n    &#x2F;&#x2F; 7. 判斷是否為曲線\n    if (avgA &gt; 20 &amp;&amp; avgA &lt; 40) &#123;\n      drawCache.push(&#123;\n        type: &quot;arc&quot;,\n        corners: corners,\n        line: [...lineCache]\n      &#125;);\n      return;\n    &#125;\n    &#x2F;&#x2F; 7. 判斷是否為直線\n    if (corners.length &#x3D;&#x3D; 2) &#123;\n      drawCache.push(&#123;\n        type: &quot;line&quot;,\n        corners: corners,\n        line: [...lineCache]\n      &#125;);\n      return;\n    &#125; else if (corners.length &#x3D;&#x3D; 3) &#123; \n      &#x2F;&#x2F; 7. 判斷是否為鍵號\n      let p0 &#x3D; corners[0];\n      let p1 &#x3D; corners[1];\n      let p2 &#x3D; ptLast;\n      let p0p1 &#x3D; delta(p0, p1);\n      let p1p2 &#x3D; delta(p1, p2);\n      if (Math.abs(angle_between(p0p1, p1p2) - Math.PI &#x2F; 4) &gt; Math.PI &#x2F; 6) &#123;\n        drawCache.push(&#123;\n          type: &quot;arrow&quot;,\n          corners: corners,\n          line: [...lineCache]\n        &#125;);\n        return;\n      &#125;\n    &#125;\n  &#125;\n  drawCache.push(&#123;\n    type: &quot;other&quot;,\n    corners: corners,\n    line: [...lineCache]\n  &#125;);\n&#125;</code></pre>\n\n<p>經過複雜且麻煩的偵測圖形後，最後就只要將偵測到的圖案更新至畫布內就大功告成了！</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 清除畫布\nfunction clear() &#123;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n&#125;\n\nfunction draw() &#123;\n  clear();\n  ctx.strokeStyle &#x3D; &quot;orange&quot;;\n  &#x2F;&#x2F; 繪製完成的筆跡\n  drawCache.forEach((e) &#x3D;&gt; &#123;\n    ctx.beginPath();\n    if (e.type &#x3D;&#x3D; &quot;line&quot;) &#123; &#x2F;&#x2F; 直線\n      let l &#x3D; e.line.length - 1;\n      ctx.moveTo(e.line[0].x, e.line[0].y);\n      ctx.lineTo(e.line[l].x, e.line[l].y);\n    &#125; else if (e.type &#x3D;&#x3D; &quot;arrow&quot;) &#123; &#x2F;&#x2F; 箭號\n      let l &#x3D; e.line.length - 1;\n      let angle &#x3D;\n        (Math.atan2(e.line[l].y - e.line[0].y, e.line[l].x - e.line[0].x) *\n          180) &#x2F;\n        Math.PI;\n      let angle1 &#x3D; ((angle + 150) * Math.PI) &#x2F; 180;\n      let angle2 &#x3D; ((angle - 150) * Math.PI) &#x2F; 180;\n      ctx.moveTo(e.line[0].x, e.line[0].y);\n      ctx.lineTo(e.line[l].x, e.line[l].y);\n      ctx.lineTo(\n        e.line[l].x + 20 * Math.cos(angle1),\n        e.line[l].y + 20 * Math.sin(angle1)\n      );\n      ctx.moveTo(e.line[l].x, e.line[l].y);\n      ctx.lineTo(\n        e.line[l].x + 20 * Math.cos(angle2),\n        e.line[l].y + 20 * Math.sin(angle2)\n      );\n    &#125; else if (e.type &#x3D;&#x3D; &quot;rect&quot;) &#123; &#x2F;&#x2F; 矩形\n      ctx.strokeStyle &#x3D; &quot;orange&quot;;\n      ctx.beginPath();\n      ctx.moveTo(e.corners[0].x, e.corners[0].y);\n      e.corners.forEach((p) &#x3D;&gt; ctx.lineTo(p.x, p.y));\n    &#125; else if (e.type &#x3D;&#x3D; &quot;arc&quot;) &#123; &#x2F;&#x2F; 曲線\n      ctx.moveTo(e.corners[0].x, e.corners[0].y);\n      for (var i &#x3D; 0; i &lt; e.corners.length - 1; i++) &#123;\n        var x_mid &#x3D; (e.corners[i].x + e.corners[i + 1].x) &#x2F; 2;\n        var cp_x1 &#x3D; (x_mid + e.corners[i].x) &#x2F; 2;\n        var cp_y1 &#x3D; i % 2 &#x3D;&#x3D; 0 ? e.corners[i + 1].y : e.corners[i].y;\n        ctx.quadraticCurveTo(\n          cp_x1,\n          cp_y1,\n          e.corners[i + 1].x,\n          e.corners[i + 1].y\n        );\n      &#125;\n    &#125; else if (e.type &#x3D;&#x3D; &quot;circle&quot;) &#123; &#x2F;&#x2F; 圓形或橢圓形\n      ctx.ellipse(\n        (e.corners[0].x + e.corners[1].x) &#x2F; 2,\n        (e.corners[2].y + e.corners[3].y) &#x2F; 2,\n        Math.abs(e.corners[1].x - e.corners[0].x) &#x2F; 2,\n        Math.abs(e.corners[3].y - e.corners[2].y) &#x2F; 2,\n        0,\n        0,\n        Math.PI * 2\n      );\n    &#125; else &#123; &#x2F;&#x2F; 其他\n      ctx.beginPath();\n      ctx.moveTo(e.corners[0].x, e.corners[0].y);\n      e.corners.forEach((p) &#x3D;&gt; ctx.lineTo(p.x, p.y));\n    &#125;\n    ctx.stroke();\n  &#125;);\n  &#x2F;&#x2F; 正在繪製的筆跡\n  ctx.strokeStyle &#x3D; &quot;pink&quot;;\n  if (lineCache.length &gt; 1) &#123;\n    ctx.beginPath();\n    ctx.moveTo(lineCache[0].x, lineCache[0].y);\n    lineCache.forEach((p) &#x3D;&gt; &#123;\n      ctx.lineTo(p.x, p.y);\n    &#125;);\n    ctx.stroke();\n  &#125;\n  &#x2F;&#x2F; 沒有任何筆跡\n  if (lineCache.length + drawCache.length &#x3D;&#x3D; 0)\n    ctx.fillText(\n      &quot;Draw Something Here.&quot;,\n      canvas.width * 0.4,\n      canvas.height * 0.45\n    );\n&#125;</code></pre>","text":"在iOS的備忘錄或Samsung Note App裡畫畫都可以將手畫的筆跡轉換成漂亮的圖形，讓我不禁想嘗試HTML5的Canvas是不是也可以做到，今天就來記錄一下如何將HTML5 Canvas上醜醜的圖形變成漂亮的直線、箭號、矩形等等。 開心地展示時間 See the Pen ...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Javascript","slug":"Javascript","count":2,"path":"api/categories/Javascript.json"}],"tags":[{"name":"Javascript","slug":"Javascript","count":2,"path":"api/tags/Javascript.json"},{"name":"Web","slug":"Web","count":3,"path":"api/tags/Web.json"},{"name":"HTML5 Canvas","slug":"HTML5-Canvas","count":1,"path":"api/tags/HTML5-Canvas.json"},{"name":"Shape recognition","slug":"Shape-recognition","count":1,"path":"api/tags/Shape-recognition.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%96%8B%E5%BF%83%E5%9C%B0%E5%B1%95%E7%A4%BA%E6%99%82%E9%96%93\"><span class=\"toc-text\">開心地展示時間</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E6%96%87\"><span class=\"toc-text\">正文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#HTML\"><span class=\"toc-text\">HTML</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CSS\"><span class=\"toc-text\">CSS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JS\"><span class=\"toc-text\">JS</span></a></li></ol></li></ol>","author":{"name":"Shirley","slug":"shirley","avatar":"https://i.imgur.com/lM0jHtF.png","link":"/","description":"記錄雜七雜八的秘密基地","socials":{"github":"https://github.com/cailirl980519","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"book":{"icon":"fa fa-envelope","link":"mailto://cailirl980519@gmail.com"}}}},"mapped":true,"prev_post":{"title":"用Isolate實現Loading Widget不卡頓","uid":"2a6644c694560b69458b953b3d0b9644","slug":"flutter-isolate","date":"2021-12-16T07:14:06.000Z","updated":"2022-02-16T01:41:50.247Z","comments":true,"path":"api/articles/flutter-isolate.json","keywords":"Flutter, Dart, MSIX, webview_windows, Javascript, Web, VBA, Excel","cover":[],"text":" Flutter預設是單執行緒處理，在你還沒發覺UI變得卡頓時，你是不會發現的。 剛開始接觸Flutter時，完全沒有認真研究過他的執行序，認為只要把複雜或需要時間的工作丟進Future, async, await就解決一切了，直到…我發現UI變得超卡的！！於是就誕生了這篇文章…...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Flutter","slug":"Flutter","count":4,"path":"api/categories/Flutter.json"}],"tags":[{"name":"App","slug":"App","count":5,"path":"api/tags/App.json"},{"name":"Flutter","slug":"Flutter","count":4,"path":"api/tags/Flutter.json"},{"name":"Dart","slug":"Dart","count":4,"path":"api/tags/Dart.json"},{"name":"Isolate","slug":"Isolate","count":1,"path":"api/tags/Isolate.json"}],"author":{"name":"Shirley","slug":"shirley","avatar":"https://i.imgur.com/lM0jHtF.png","link":"/","description":"記錄雜七雜八的秘密基地","socials":{"github":"https://github.com/cailirl980519","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"book":{"icon":"fa fa-envelope","link":"mailto://cailirl980519@gmail.com"}}}}},"next_post":{"title":"透過Pointer events偵測多點觸控","uid":"13b3e19acd1214ea9632a399d02fbfc3","slug":"js-zoom-by-pointer","date":"2021-10-22T06:17:53.000Z","updated":"2021-12-16T01:39:02.565Z","comments":true,"path":"api/articles/js-zoom-by-pointer.json","keywords":"Flutter, Dart, MSIX, webview_windows, Javascript, Web, VBA, Excel","cover":null,"text":"在多平台的時代，瀏覽器的輸入事件也越來越多樣化，從早期只有滑鼠可以點擊畫面，到現在有了觸控、觸控筆，於是Pointer events誕生了，它不僅保留了Mouse events的常見屬性，還多了可以追蹤各種類型指針事件的功能，使程式碼可以相容各種不同類型的裝置。 Pointer ...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Javascript","slug":"Javascript","count":2,"path":"api/categories/Javascript.json"}],"tags":[{"name":"Javascript","slug":"Javascript","count":2,"path":"api/tags/Javascript.json"},{"name":"Web","slug":"Web","count":3,"path":"api/tags/Web.json"},{"name":"Pointer events","slug":"Pointer-events","count":1,"path":"api/tags/Pointer-events.json"}],"author":{"name":"Shirley","slug":"shirley","avatar":"https://i.imgur.com/lM0jHtF.png","link":"/","description":"記錄雜七雜八的秘密基地","socials":{"github":"https://github.com/cailirl980519","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"book":{"icon":"fa fa-envelope","link":"mailto://cailirl980519@gmail.com"}}}}}}